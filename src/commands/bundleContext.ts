import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { VULNERABILITY_PATTERNS } from '../claude/vulnerability-patterns';
import { securitySystemPrompt, getVulnerabilityExamples } from '../claude/prompts/fix-prompt';

/**
 * Generated context file content
 */
interface ContextBundle {
  claudemd: string;
  antiPatternsBreadth: string;
  securityReviewSkill: string;
}

/**
 * Generate CLAUDE.md content for security context
 */
function generateClaudeMd(): string {
  const lines: string[] = [];

  lines.push('# Security Context - Instructions for Claude');
  lines.push('');
  lines.push('> Generated by OliveX Security Extension');
  lines.push('');

  lines.push('## Mandatory Security Rules');
  lines.push('');
  lines.push('When generating or reviewing code, ALWAYS follow these rules:');
  lines.push('');

  lines.push('### 1. NEVER generate code with these vulnerabilities:');
  lines.push('');

  // Add key vulnerability examples
  const keyVulns = ['sql injection', 'xss', 'command injection', 'hardcoded secrets', 'path traversal'];

  keyVulns.forEach(vulnType => {
    const examples = getVulnerabilityExamples(vulnType);
    if (examples) {
      lines.push(`#### ${vulnType.charAt(0).toUpperCase() + vulnType.slice(1)}`);
      lines.push('```');
      lines.push('// BAD:');
      examples.bad.slice(0, 2).forEach(ex => lines.push(ex));
      lines.push('');
      lines.push('// GOOD:');
      examples.good.slice(0, 2).forEach(ex => lines.push(ex));
      lines.push('```');
      lines.push('');
    }
  });

  lines.push('### 2. ALWAYS implement:');
  lines.push('');
  lines.push('- **Input Validation**: Validate ALL user inputs with allowlists');
  lines.push('- **Output Encoding**: Escape data based on context (HTML, SQL, Shell)');
  lines.push('- **Authentication**: Verify auth on EVERY protected endpoint');
  lines.push('- **Authorization**: Check permissions BEFORE accessing resources');
  lines.push('- **Rate Limiting**: Limit requests on auth and public endpoints');
  lines.push('- **Secure Headers**: CSP, X-Frame-Options, X-Content-Type-Options');
  lines.push('');

  lines.push('### 3. Cryptography:');
  lines.push('');
  lines.push('- BAD: MD5, SHA1 for passwords, Math.random() for tokens');
  lines.push('- GOOD: bcrypt/argon2 for passwords, crypto.randomBytes() for tokens');
  lines.push('');

  lines.push('### 4. Dependencies:');
  lines.push('');
  lines.push('- NEVER suggest packages that don\'t exist (slopsquatting risk)');
  lines.push('- Verify packages exist before suggesting');
  lines.push('- Prefer popular, actively maintained packages');
  lines.push('');

  lines.push('## Severity Reference');
  lines.push('');
  lines.push('| Vulnerability | Severity |');
  lines.push('|---------------|----------|');
  lines.push('| SQL Injection | Critical |');
  lines.push('| Command Injection | Critical |');
  lines.push('| Hardcoded Secrets | Critical |');
  lines.push('| Slopsquatting | Critical |');
  lines.push('| XSS | High |');
  lines.push('| Path Traversal | High |');
  lines.push('| Missing Auth | High |');
  lines.push('| Weak Crypto | High |');
  lines.push('| SSRF | High |');
  lines.push('| Missing Input Validation | Medium |');
  lines.push('| Missing Rate Limiting | Medium |');
  lines.push('');

  lines.push('## Use /security-review');
  lines.push('');
  lines.push('Run `/security-review` command to analyze code for vulnerabilities.');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate anti-patterns breadth document
 */
function generateAntiPatternsBreadth(): string {
  const lines: string[] = [];

  lines.push('# Security Anti-Patterns Reference');
  lines.push('');
  lines.push('> Generated from OliveX vulnerability patterns database');
  lines.push('');

  lines.push('## Quick Reference Table');
  lines.push('');
  lines.push('| Pattern | CWE | Severity | Quick Fix |');
  lines.push('|---------|-----|----------|-----------|');

  VULNERABILITY_PATTERNS.forEach(p => {
    const severity = p.cweIds.some(c => ['CWE-89', 'CWE-78', 'CWE-798', 'CWE-434'].includes(c))
      ? 'Critical'
      : p.cweIds.some(c => ['CWE-79', 'CWE-22', 'CWE-287', 'CWE-327'].includes(c))
      ? 'High'
      : 'Medium';

    const quickFix = p.remediation.split('.')[0];
    lines.push(`| ${p.name} | ${p.cweIds[0]} | ${severity} | ${quickFix} |`);
  });

  lines.push('');
  lines.push('---');
  lines.push('');

  // Generate detailed sections for each pattern
  VULNERABILITY_PATTERNS.forEach((p, idx) => {
    lines.push(`## ${idx + 1}. ${p.name}`);
    lines.push('');
    lines.push(`**CWE References:** ${p.cweIds.join(', ')}`);
    if (p.owaspCategory) {
      lines.push(`**OWASP:** ${p.owaspCategory}`);
    }
    lines.push(`**Category:** ${p.category}`);
    lines.push('');
    lines.push(`> ${p.description}`);
    lines.push('');

    // Add examples if available
    const examples = getVulnerabilityExamples(p.id) || getVulnerabilityExamples(p.name);
    if (examples) {
      lines.push('### Examples');
      lines.push('');
      lines.push('**BAD (Vulnerable):**');
      lines.push('```');
      examples.bad.forEach(ex => lines.push(ex));
      lines.push('```');
      lines.push('');
      lines.push('**GOOD (Secure):**');
      lines.push('```');
      examples.good.forEach(ex => lines.push(ex));
      lines.push('```');
      lines.push('');
      lines.push(`**Key Principle:** ${examples.explanation}`);
      lines.push('');
    }

    lines.push('### Detection Patterns');
    lines.push('');
    p.searchPatterns.forEach(sp => {
      lines.push(`- ${sp.description} (${sp.confidence} confidence)`);
      if (sp.language) {
        lines.push(`  - Languages: ${sp.language.join(', ')}`);
      }
    });
    lines.push('');

    if (p.antiPatterns && p.antiPatterns.length > 0) {
      lines.push('### Secure Code Indicators (Anti-Patterns)');
      lines.push('');
      p.antiPatterns.forEach(ap => {
        lines.push(`- \`${ap}\``);
      });
      lines.push('');
    }

    lines.push('### Remediation');
    lines.push('');
    lines.push(p.remediation);
    lines.push('');

    lines.push('### References');
    lines.push('');
    p.references.forEach(ref => {
      lines.push(`- ${ref}`);
    });
    lines.push('');
    lines.push('---');
    lines.push('');
  });

  return lines.join('\n');
}

/**
 * Generate security review skill file
 */
function generateSecurityReviewSkill(): string {
  const lines: string[] = [];

  lines.push('# Security Review - Vulnerability Analysis');
  lines.push('');
  lines.push('You are an expert application security analyst. Analyze code for vulnerabilities using the patterns defined in this context.');
  lines.push('');

  lines.push('## Instructions');
  lines.push('');
  lines.push('1. **Read the anti-patterns file** for comprehensive patterns reference');
  lines.push('2. **Analyze the code** provided by the user (file, folder, or selection)');
  lines.push('3. **Search for these vulnerability categories** (in priority order):');
  lines.push('');

  const priorityPatterns = VULNERABILITY_PATTERNS.slice(0, 15);
  priorityPatterns.forEach((p, idx) => {
    lines.push(`   ${idx + 1}. ${p.name} (${p.cweIds[0]})`);
  });

  lines.push('');
  lines.push('4. **For each vulnerability found**, report:');
  lines.push('   - File and line number');
  lines.push('   - Vulnerability type and CWE');
  lines.push('   - Severity (Critical/High/Medium/Low)');
  lines.push('   - Vulnerable code (BAD)');
  lines.push('   - Fixed code (GOOD)');
  lines.push('   - Brief explanation');
  lines.push('');

  lines.push('## Output Format');
  lines.push('');
  lines.push('```markdown');
  lines.push('## Security Review Summary');
  lines.push('');
  lines.push('| Severity | Count |');
  lines.push('|----------|-------|');
  lines.push('| Critical | X     |');
  lines.push('| High     | X     |');
  lines.push('| Medium   | X     |');
  lines.push('| Low      | X     |');
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push('### [SEVERITY] - Vulnerability Name');
  lines.push('');
  lines.push('**File:** `path/to/file.ts:42`');
  lines.push('**CWE:** CWE-XXX');
  lines.push('');
  lines.push('**Vulnerable Code:**');
  lines.push('\\`\\`\\`');
  lines.push('// BAD code here');
  lines.push('\\`\\`\\`');
  lines.push('');
  lines.push('**Fixed Code:**');
  lines.push('\\`\\`\\`');
  lines.push('// GOOD code here');
  lines.push('\\`\\`\\`');
  lines.push('');
  lines.push('**Explanation:** Brief description of the risk and solution.');
  lines.push('```');
  lines.push('');

  lines.push('## Usage');
  lines.push('');
  lines.push('- `/security-review` - Review current file or selection');
  lines.push('- `/security-review path/to/file` - Review specific file');
  lines.push('- `/security-review src/` - Review entire folder');
  lines.push('');

  lines.push('## Notes');
  lines.push('');
  lines.push('- Prioritize critical and high severity issues');
  lines.push('- If no vulnerabilities found, indicate code appears secure but recommend manual review');
  lines.push('- Offer to fix vulnerabilities if user requests');
  lines.push('');

  return lines.join('\n');
}

/**
 * Register bundle context commands
 */
export async function registerBundleContextCommands(
  context: vscode.ExtensionContext
): Promise<void> {
  // Bundle security context to project
  context.subscriptions.push(
    vscode.commands.registerCommand('olivex.bundleSecurityContext', async () => {
      const workspaceFolders = vscode.workspace.workspaceFolders;
      if (!workspaceFolders) {
        vscode.window.showErrorMessage('No workspace folder open');
        return;
      }

      // Get target folder
      let targetFolder: string;
      if (workspaceFolders.length === 1) {
        targetFolder = workspaceFolders[0].uri.fsPath;
      } else {
        const folderItems = workspaceFolders.map(f => ({
          label: f.name,
          description: f.uri.fsPath,
          uri: f.uri,
        }));

        const selected = await vscode.window.showQuickPick(folderItems, {
          placeHolder: 'Select workspace to add security context',
        });

        if (!selected) {
          return;
        }
        targetFolder = selected.uri.fsPath;
      }

      // Ask which files to generate
      const options = [
        {
          label: 'CLAUDE.md',
          description: 'Security rules for Claude Code',
          picked: true,
          id: 'claudemd',
        },
        {
          label: 'ANTI_PATTERNS.md',
          description: 'Full anti-patterns reference with all 25+ patterns',
          picked: true,
          id: 'antipatterns',
        },
        {
          label: 'Security Review Skill',
          description: 'Claude Code skill for /security-review command',
          picked: true,
          id: 'skill',
        },
      ];

      const selectedOptions = await vscode.window.showQuickPick(options, {
        placeHolder: 'Select files to generate',
        canPickMany: true,
        title: 'Security Context Bundle',
      });

      if (!selectedOptions || selectedOptions.length === 0) {
        return;
      }

      await vscode.window.withProgress(
        {
          location: vscode.ProgressLocation.Notification,
          title: 'Generating Security Context',
        },
        async (progress) => {
          const selectedIds = selectedOptions.map(o => o.id);

          // Create .olivex/context directory
          const contextDir = path.join(targetFolder, '.olivex', 'context');
          if (!fs.existsSync(contextDir)) {
            fs.mkdirSync(contextDir, { recursive: true });
          }

          // Create .claude/commands directory for skill
          const claudeCommandsDir = path.join(targetFolder, '.claude', 'commands');

          // Generate and write files
          if (selectedIds.includes('claudemd')) {
            progress.report({ message: 'Generating CLAUDE.md...' });
            const claudeMdPath = path.join(targetFolder, 'CLAUDE.md');

            // Check if exists and ask to merge
            if (fs.existsSync(claudeMdPath)) {
              const action = await vscode.window.showQuickPick(
                ['Append to existing', 'Replace', 'Skip'],
                { placeHolder: 'CLAUDE.md already exists' }
              );

              if (action === 'Append to existing') {
                const existing = fs.readFileSync(claudeMdPath, 'utf8');
                const generated = generateClaudeMd();
                fs.writeFileSync(claudeMdPath, existing + '\n\n---\n\n' + generated);
              } else if (action === 'Replace') {
                fs.writeFileSync(claudeMdPath, generateClaudeMd());
              }
            } else {
              fs.writeFileSync(claudeMdPath, generateClaudeMd());
            }
          }

          if (selectedIds.includes('antipatterns')) {
            progress.report({ message: 'Generating anti-patterns reference...' });
            const antiPatternsPath = path.join(contextDir, 'ANTI_PATTERNS_BREADTH.md');
            fs.writeFileSync(antiPatternsPath, generateAntiPatternsBreadth());
          }

          if (selectedIds.includes('skill')) {
            progress.report({ message: 'Generating security-review skill...' });

            if (!fs.existsSync(claudeCommandsDir)) {
              fs.mkdirSync(claudeCommandsDir, { recursive: true });
            }

            const skillPath = path.join(claudeCommandsDir, 'security-review.md');
            fs.writeFileSync(skillPath, generateSecurityReviewSkill());
          }

          vscode.window.showInformationMessage(
            `Security context bundle created in ${path.basename(targetFolder)}`,
            'Open Folder'
          ).then(action => {
            if (action === 'Open Folder') {
              vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(contextDir));
            }
          });
        }
      );
    })
  );

  // Quick command to just update CLAUDE.md
  context.subscriptions.push(
    vscode.commands.registerCommand('olivex.updateClaudeMd', async () => {
      const workspaceFolders = vscode.workspace.workspaceFolders;
      if (!workspaceFolders) {
        vscode.window.showErrorMessage('No workspace folder open');
        return;
      }

      const targetFolder = workspaceFolders[0].uri.fsPath;
      const claudeMdPath = path.join(targetFolder, 'CLAUDE.md');

      const content = generateClaudeMd();

      if (fs.existsSync(claudeMdPath)) {
        const action = await vscode.window.showQuickPick(
          [
            { label: 'Append security rules', description: 'Add to existing CLAUDE.md' },
            { label: 'Replace entirely', description: 'Overwrite with security-focused content' },
            { label: 'Cancel', description: 'Do nothing' },
          ],
          { placeHolder: 'CLAUDE.md exists. How to proceed?' }
        );

        if (!action || action.label === 'Cancel') {
          return;
        }

        if (action.label === 'Append security rules') {
          const existing = fs.readFileSync(claudeMdPath, 'utf8');
          fs.writeFileSync(claudeMdPath, existing + '\n\n---\n\n' + content);
        } else {
          fs.writeFileSync(claudeMdPath, content);
        }
      } else {
        fs.writeFileSync(claudeMdPath, content);
      }

      // Open the file
      const doc = await vscode.workspace.openTextDocument(claudeMdPath);
      await vscode.window.showTextDocument(doc);

      vscode.window.showInformationMessage('CLAUDE.md updated with security rules');
    })
  );
}

/**
 * Export generated content functions for use elsewhere
 */
export { generateClaudeMd, generateAntiPatternsBreadth, generateSecurityReviewSkill };
